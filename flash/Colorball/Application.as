package{		/*	-Matrix shadow effect @ b	-speed testjes runnen om een maximum snelheid aan t balletje te geven	-paralax achtergrond met groene stofdeeltjes oid	-net als met tiny birds de verschillende vogels heb ik de verschillende balletjes met elk hun eigen uiterlijk/kleur	-memory probleem fixen door overlappende balletjes te wissen, dus de idle jump gaat niet printen	-RESTART GAME + RESTART THIS STAGE NA VERLIES! -> ONBEPERKT DE TIJD OM TE OEFENEN TOT JE MEMORY OP IS :D	-bij active rectangle/ball de opacity 0.8 doen -> nice effect tov opacity 1.0	-best performance met google chrome -> mwoah na nader inzien	-in de stages komt er ook 1 gouden klokje oid, dan krijg je er een aantal seconden bij, als je dit lukt kun je dus tijd winnen :D	-techniek om em op de hoek te raken -> kost je minder tijd :D	-losse software verkopen voor 1 dollar, deze software bevat een level builder + de optie om het originele spel te spelen zonder timer	- @ hierboven staande, account upgraden naar een gold-account, $1, mensen @ pre-release krijgen gold-account gratis	-@ '' betalen voor level builder, soort van developer-status, dan mag je 10 levels developen en in de level-gallery zetten	- @ collision met flag rectangle -> de ghostballetjes a la paralax laten wegfaden naar links -> stage schuift naar rechts door naar de volgende	-mensen kopen het spel niet, ze kopen een account om het spel mee te spelen -> geen illigale copies	-!!extra bescherming: mensen met een gekocht account hebben de functie om hun account op te heffen/deleten -> geen massive public free accounts =)	***||ZODRA IEMAND DE LAATSTE STAGE HEEFT GEHAALD -> COLORBAL V2	***||-> IK CONTROLEER DAT OMDAT IEDEREEN ZIJN GHOSTS WORDEN OPGESLAGEN ^^	*()TEKSTJE BIJ EERSTE STAGE (WAARSCHIJNLIJK HTML GECODE -> LEUK VOOR GOOGLE):  		CONTROLS: < [<-O) && > [O->]	GOAL: COMPLETE ALL STAGES 	RULES: HAVE FUN		//MAYBE ENKEL INZAGE IN HOOFD-HIGSCORE NA AFLOOP VAN SPEL		//als je op het randje kom -> andere hoek -> OFTEWEL MEER TACTIEKOS!	//on kill de ghostballsverwijderen met 1 buffer	..free gold account in game als powerup!		// / INITIALIZATION / CONSTRUCTION 	//colors van angry birds	//red	//blauw	//geel	//zwart	//wit	//groen	//roze	//je kan achievements sparen,		 * == preregistered	 # == world record holder	 &		*/	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.KeyboardEvent;		public class Application extends MovieClip{				private var _stageNr:int = 1;		private var _newStage:Stage;		private var _newGameTimer:GameTimer;				private var _memoryUsedInKb:Number		private var _frameCounter:int;		private var _activeKey:int;				private var _isCollided:Boolean;		private var _collisionCounter:int;				public function Application(){						stage.frameRate = 60;			stage.addEventListener(KeyboardEvent.KEY_DOWN, clickHandler);			stage.addEventListener(KeyboardEvent.KEY_UP, clickHandler);						nextStage(this._stageNr);						stage.addEventListener(Event.ENTER_FRAME, gameEngine);						this._newGameTimer = new GameTimer(stage.stageWidth, this._newStage.mainColor)			addChild(this._newGameTimer);		}				private function nextStage(stageNr:int):void{						this._stageNr = stageNr;						if(this._newStage != null){				removeChild(this._newStage);								this._stageNr++;			}						this._newStage = new Stage(this._stageNr, stage.stageWidth, stage.stageHeight);						addChild(this._newStage);		}				private function gameEngine(e:Event):void{						//FOR EACH MOVABLE BALL IN PLAY			for(var mBA:int = 0; mBA < this._newStage.newMovableBallArray.length; mBA++){								checkLineCollision(this._newStage.newMovableBallArray[mBA]);								checkFlagRectangleCollision(this._newStage.newMovableBallArray[mBA]);								this._newStage.printGhost("live");								if(this._newStage.newMovableBallArray[mBA].isMoving == true)					this._newStage.printGhost("permanent");								this._newStage.newMovableBallArray[mBA].moveObj();			}		}				private function checkLineCollision(mB:movableBall):void{						//INITIALIZE VARIABLES			var collision:Boolean;			var collisionCounter:int;			var posArr = mB.calcNextPos();			var newGhostBall:Ball = new Ball(posArr[0], posArr[1], mB.radius, 0xff0000, 2);			var candidateLineArray:Array = new Array();			var trueLineArray:Array = new Array();							//FOR EACH LINE ON STAGE			for(var lA:int = 0; lA < this._newStage.newLineArray.length; lA++){									if(newGhostBall.hitTestObject(this._newStage.newLineArray[lA]) == true){										collisionCounter++;										candidateLineArray.push(this._newStage.newLineArray[lA])				}								//ON ENDING LOOP				if(lA == (this._newStage.newLineArray.length - 1)){										if(collisionCounter == 1){												trace("SINGLE COLLISION");						collision = true;												trueLineArray.push(candidateLineArray[0]);					}										if(collisionCounter > 1){												trace("MULTIPLE COLLISION");						trace("TIME TO CALCULATE PIXEL-PERFECT");												var mcPosArray:Array = new Array();												var xDiffRight:Number = ((newGhostBall.x - mB.x) / 10);						var xDiffLeft:Number = -1 * ((mB.x - newGhostBall.x) / 10);						var yDiffUp:Number = -1 * ((mB.y - newGhostBall.y) / 10);						var yDiffDown:Number = ((newGhostBall.y - mB.y) / 10);												mcPosArray[0] = mB.x;						mcPosArray[1] = mB.y;												//WHILE THERE IS NO COLLISION						while(collision == false){													if(this._isCollided == false){																if(mB.isMovingRight == true)									mcPosArray[0] += xDiffRight;																if(mB.isMovingLeft == true)									mcPosArray[0] += xDiffLeft;																if(mB.isMovingUp == true)									mcPosArray[1] += yDiffUp;																else mcPosArray[1] += yDiffDown;																collision = checkCollisionExtra(mcPosArray);							}						}												function checkCollisionExtra(mcPosArray:Array):Boolean{														var collisionX:Boolean;							var newGhostBallX:Ball = new Ball(mcPosArray[0], mcPosArray[1], 8, 0xff0000, 2);														trace("NEW GHOST-COORDINATES: x(" + newGhostBallX.x + "), y(" + newGhostBallX.y + ")");							trace("executing hittest..");														//FOR EACH CANDIDATE LINE							for(var cL:int = 0; cL < candidateLineArray.length; cL++){																if(newGhostBallX.hitTestObject(candidateLineArray[cL]) == true){																			trace("*collission detected on line " + cL);																		collisionX = true;																		trueLineArray.push(candidateLineArray[cL]);								}							}														trace("result: collission is " + collisionX);														return collisionX;						}					}				}			}						if(collision == true){									//FOR EACH TRUE LINE					for(var tL:int = 0; tL < trueLineArray.length; tL++){												mB.bounce(trueLineArray[tL]);						trueLineArray[tL].setAlpha(1);					}			}						//this._isCollided = false;			//this._collisionCounter = 0;		}				private function checkFlagRectangleCollision(mB:movableBall):void		{			//FOR EACH FLAG RECTANGLE ON STAGE			for(var k:int = 0; k < this._newStage.newFlagRectangleArray.length; k++){										if(mB.hitTestObject(this._newStage.newFlagRectangleArray[k]) == true){												stopTimer();												if(this._newGameTimer.timerIsLocked == false)//BUGFIX (DURATION OF COLLISION -> UNWANTED COLOR)							this._newStage.newFlagRectangleArray[k].drawActiveRectangle();/////////////////////////////						mB.drawActiveBall();												nextStage(this._stageNr);												removeChild(this._newGameTimer);//BUGFIX (STAGE COMPLETED -> TIMER INVISIBLE)						this._newGameTimer.colorSwitch(this._newStage.mainColor);												addChild(this._newGameTimer);					}				}		}				private function clickHandler(e:KeyboardEvent):void		{			//trace("Current keycode: " + e.keyCode);						if(e.type == "keyDown" && e.keyCode == 32)				stage.frameRate = 4;							if(e.type == "keyUp" && e.keyCode == 32)				stage.frameRate = 60;						for(var n:int = 0; n < this._newStage.newMovableBallArray.length; n++) 			{								if(e.type == "keyDown")				{					if(e.keyCode == this._newStage.newMovableBallArray[n].keyCodeRight || e.keyCode == this._newStage.newMovableBallArray[n].keyCodeLeft)					{						switch(e.keyCode)						{							case this._newStage.newMovableBallArray[n].keyCodeRight:							this._newStage.newMovableBallArray[n].activeKey = e.keyCode;							this._newStage.newMovableBallArray[n].curDirection = ("right");							break;															case this._newStage.newMovableBallArray[n].keyCodeLeft:							this._newStage.newMovableBallArray[n].activeKey = e.keyCode;							this._newStage.newMovableBallArray[n].curDirection = ("left");							break;						}													this._newStage.newMovableBallArray[n].isMoving = (true);						this.addEventListener(Event.ENTER_FRAME, this._newStage.newMovableBallArray[n].accelerate);						this._newGameTimer.startTimer();					}				}								if(e.type == "keyUp")				{					if(e.keyCode == this._newStage.newMovableBallArray[n].keyCodeRight || e.keyCode == this._newStage.newMovableBallArray[n].keyCodeLeft)					{						if(e.keyCode == this._newStage.newMovableBallArray[n].activeKey)						{							this._newStage.newMovableBallArray[n].isMoving = (false);							this.removeEventListener(Event.ENTER_FRAME, this._newStage.newMovableBallArray[n].accelerate);							this._newGameTimer.stopTimer();						}					}				}			}		}				private function renderLoop():void		{					}				public function stopTimer():void		{			this._newGameTimer.stopTimer();		}				private function resetTimer():void		{			this._newGameTimer.resetTimer();		}	}	}