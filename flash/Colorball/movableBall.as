package {	import flash.events.Event;	public class movableBall extends Ball	{		private var _displayWidth:int;				private var _xPos:int;		private var _yPos:int;		private var _prevXPos:int;		private var _newXPos:int;		private var _curYPos:int;		private var _newYPos:int;		private var _radius:int;		private var _color:uint;				private var _xVelRight:Number = 0;		private var _xVelLeft:Number = 0;		private var _yVelUp:Number = 0;		private var _yVelDown:Number = 0.4;		private var _maxXVel:int = 15;//TOP-SPEED		private var _maxYVel:int = 15;//TOP-SPEED		private var _isMovingUp:Boolean;		private var _isMovingRight:Boolean;		private var _isMovingDown:Boolean;		private var _isMovingLeft:Boolean;				private var _isMoving:Boolean;		private var _isAccelerating:Boolean;		private var _autoBounceVel:Number = 11.5;//INFINITE BOUNCING		private var _gravity:Number = 0.40;		private var _acc:Number = 0.21;		private var _eas:Number = 0.09;		private var _curDirection:String;		private var _keyCodeRight:int;		private var _keyCodeLeft:int;		private var _activeKey:int;		public function movableBall(xPos:int, yPos:int, radius:int, color:uint, lineWidth:int, keyCodeRight:int, keyCodeLeft:int)		{			super(xPos, yPos, radius, color, lineWidth);			this._xPos = xPos;			this._yPos = yPos;			this._radius = radius;			this._color = color;			this._keyCodeRight = keyCodeRight;			this._keyCodeLeft = keyCodeLeft;						this._displayWidth = (this._radius + 4);		}		public function moveObj():void{						gravitate();						//ON PLAYER MOVEMENT			if(this._xVelRight > 0 || this._xVelLeft > 0)				ease();							determineDirection();								securePositiveVel();							this.x += (this._xVelRight - this._xVelLeft);			this.y += (this._yVelDown - this._yVelUp);						checkBoundry();						//trace("IS MOVING DOWN: " + this._isMovingDown);			//trace("IS MOVING RIGHT: " + this._isMovingRight);						/*trace("Current xVelRight: " + this._xVelRight);			trace("Current xVelLeft: " + this._xVelLeft);			trace("Current  yVelUp: " + this._yVelUp);			trace("Current  yVelDown: " + this._yVelDown);//*/		}		public function accelerate(e:Event):void{						if(this._xVelRight <= this._maxXVel && this._curDirection == "right")				this._xVelRight +=  _acc;			if(this._xVelLeft <= this._maxXVel && this._curDirection == "left")				this._xVelLeft +=  _acc;		}				private function gravitate():void{						//ON RISING			if(this._yVelUp > 0)				this._yVelUp -= this._gravity;			//ON FALLING			else if(this._yVelDown >= 0)				this._yVelDown += this._gravity;		}				private function ease():void{						_xVelRight -=  _eas;			_xVelLeft -=  _eas;		}				private function determineDirection():void{						if(this._yVelUp > this._yVelDown){				this._isMovingUp = true;				this._isMovingDown = false;			}							else if(this._yVelDown > this._yVelUp){				this._isMovingDown = true;				this._isMovingUp = false;			}							if(this._xVelRight >this._xVelLeft){				this._isMovingRight = true;				this._isMovingLeft = false;			}						else if(this._xVelLeft >this._xVelRight){				this._isMovingLeft = true;				this._isMovingRight = false;			}		}				private function securePositiveVel():void{						if(this._xVelRight < 0)				this._xVelRight = 0;			if(this._xVelLeft < 0)				this._xVelLeft = 0;							if(this._yVelUp < 0)				this._yVelUp = 0;			if(this._yVelDown < 0)				this._yVelDown = 0;		}		private function checkBoundry():void{						if((this.y - this._radius) >= 600)				respawn();		}				public function calcNextPos():Array{						var posArray:Array = new Array();						var nextXPos:int = (this.x + (this._xVelRight - this._xVelLeft));			var nextYPos:int = (this.y + (this._yVelDown - this._yVelUp));						posArray.push(nextXPos);			posArray.push(nextYPos);						return posArray;		}		public function bounce(collidedObject:Object):void{							//ON VERTICAL LINE			if(collidedObject.xPosStart == collidedObject.xPosEnd){									if(this.isMovingRight == true){											this.x = collidedObject.xPosStart - this._displayWidth;					this._xVelLeft = (this._xVelRight * 0.9);					this._xVelRight = 0;					trace("Bounce leftwards!");				}							else if(this.isMovingLeft == true){											this.x = collidedObject.xPosStart + this._displayWidth;					this._xVelRight = (this._xVelLeft * 0.9);					this._xVelLeft = 0;					trace("Bounce rightwards!");				}			}							//ON HORIZONTAL LINE			else if(collidedObject.yPosStart == collidedObject.yPosEnd){									//IS MOVING DOWN				if(this._isMovingDown == true){											trace("Bounce upwards! Current yVelDown: " + this._yVelDown);											if(this._yVelDown < this._autoBounceVel)						this._yVelDown = this._autoBounceVel;											this._yVelUp = (this._yVelDown * 0.9);					this._yVelDown = 0;											this.y = collidedObject.yPosStart - this._displayWidth;				}									//IS MOVING UP				else if(this._isMovingUp == true){											this._yVelDown = (this._yVelUp * 0.9);					this._yVelUp = 0;											this.y = collidedObject.yPosStart + this._displayWidth;					trace("Bounce downwards!");				}			}		}				private function respawn():void		{			//trace("Respawn");				this.x = this._xPos;			this.y = this._yPos;				this._xVelRight = 0;			this._xVelLeft = 0;				this._yVelUp = 0;			this._yVelDown = 0;		}			public function drawActiveBall():void		{			this.graphics.clear();			this.graphics.beginFill(this._color, 0.5);			this.graphics.lineStyle(2, this._color);			this.graphics.drawCircle(0, 0, this._radius);			this.graphics.endFill();		}	public function get keyCodeRight():int	{		return this._keyCodeRight;	}	public function get keyCodeLeft():int	{		return this._keyCodeLeft;	}	public function get activeKey():int	{		return this._activeKey;	}	public function set activeKey(v:int):void	{		this._activeKey = v;	}	public function get color():uint	{		return this._color;	}	public function get isMoving():Boolean	{		return this._isMoving;	}	public function get radius():int	{		return this._radius;	}	public function set curDirection(v:String):void	{		this._curDirection = v;	}	public function set isMoving(v:Boolean):void	{		this._isMoving = v;	}		public function get isMovingUp():Boolean	{		return this._isMovingUp;	}		public function get isMovingRight():Boolean	{		return this._isMovingRight;	}		public function get isMovingDown():Boolean	{		return this._isMovingDown;	}		public function get isMovingLeft():Boolean	{		return this._isMovingLeft;	}	}}